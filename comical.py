#
# Comical v1.0.0
# Convert a video file with subtitles to a PDF graphic novel
# (c) 2018 PJ Evans <pj@mrpjevans.com>
# See LICENCE and README.md for more details
# @mrpjevans
#
import xml.etree.ElementTree as ET
import sys
import os
import argparse
import subprocess
import shutil
import arrow
from fpdf import FPDF

# Parse command line
ap = argparse.ArgumentParser()
ap.add_argument("-i", "--input", required=True, help="Source video file")
ap.add_argument("-o", "--output", required=True, help="PDF to output")
ap.add_argument("-f", "--full", required=False, help="Full conversion",
                action="store_true")
ap.add_argument("-p", "--prebuild", required=False,
                help="All steps except build", action="store_true")
ap.add_argument("-e", "--extract", required=False,
                help="Extract subtitle PNGs from video file",
                action="store_true")
ap.add_argument("-c", "--clean", required=False,
                help="Clean up extracted subtitles", action="store_true")
ap.add_argument("-r", "--ocr", required=False, help="OCR cleaned subtitles",
                action="store_true")
ap.add_argument("-m", "--images", required=False,
                help="Extract images based on subtitles", action="store_true")
ap.add_argument("-d", "--detectscenes", required=False,
                help="Detect scene changes", action="store_true")
ap.add_argument("-s", "--extractscenes", required=False,
                help="Extract scene change images", action="store_true")
ap.add_argument("-b", "--build", required=False, help="Build the PDF",
                action="store_true")
ap.add_argument("--fontsize", required=False, help="Font size", default=8)
ap.add_argument("--lineheight", required=False, help="Line height", default=5)
ap.add_argument("--offset", required=False, help="Line height", default=68)
args = vars(ap.parse_args())

# Paths
path = os.path.dirname(os.path.realpath(__file__))
videoFile = os.path.abspath(args['input'])
pdfFile = os.path.abspath(args['output'])
baseDir = os.path.dirname(videoFile)
baseName = os.path.splitext(videoFile)[0]
subsDir = baseName + '.d'
xmlFile = baseName + '.xml'  # The XML file generated by ccextrator
outDir = baseName + '_process'  # Our working directory
fullRun = args['full']
preBuild = args['prebuild']

# Set font
fontFile = path + "/BackIssuesBB_reg.ttf"
fontSize = args['fontsize']
fontLineHeight = args['lineheight']
fontOffset = args['offset']

print('Comical')

if fullRun:
    print('Processing all steps')
if preBuild:
    print('Processing steps 1-6')

# Check the input file
if not os.path.isfile(videoFile):
    print('Video file not found: ' + videoFile)
    sys.exit()

# Step 1 - Extract the subtitles
if args['extract'] or fullRun or preBuild:
    print('[1/7] Extracting subtitle images')
    subprocess.call('ccextractor {} -out=spupng -quiet'.format(videoFile),
                    shell=True)

# Step 2 - Prepare the titles for OCR
if args['clean'] or fullRun or preBuild:
    print('[2/7] Cleaning subtitle images')
    mogrifyCmd = 'mogrify -resize 400% -monochrome -channel RGB'
    mogrifyCmd += ' -negate -blur 5 -threshold 70% {}/*.png'
    subprocess.call(mogrifyCmd.format(subsDir), shell=True)

# Step 3 - OCR the subtitles
if args['ocr'] or fullRun or preBuild:
    print('[3/7] OCRing the subtitles')
    subtitlePNGs = os.listdir(subsDir)
    subtitlePNGsLen = len(subtitlePNGs)
    subtitlePNGsCount = 0
    for file in subtitlePNGs:
        filename, fileExtension = os.path.splitext(file)
        if fileExtension == '.png':
            subtitlePNGsCount += 1
            print('OCRing {} of {}'.format(subtitlePNGsCount, subtitlePNGsLen))
            subtitleFile = subsDir + '/' + file
            subprocess.call('tesseract {} {} > /dev/null'.format(subtitleFile,
                                                                 subtitleFile),
                            shell=True)

# Step 4 - Extract the image for each subtitle
if args['images'] or fullRun or preBuild:
    print('[4/7] Extracting images based on subtitle timestamps')
    extractImageCmdTemplate = 'ffmpeg -loglevel panic -y -ss {} -i ' + videoFile + ' -vframes 1 -q:v 2 {}'

    try:
        os.mkdir(outDir)
    except FileExistsError:
        print('Warning: Output directory already exists')

    # Read in the XML file
    xml = ET.parse(xmlFile)
    root = xml.getroot()

    # For each subtitle
    spuNodeLen = len(root[0])
    spuNodeLenCount = 0
    for spu in root[0]:
        if(spu.attrib['start'].find(":") != -1):
            subtitleStartTime = arrow.get("1970-01-01 " + spu.attrib['start'],
                                          "YYYY-MM-DD HH:mm:ss:SS").timestamp
        else:
            subtitleStartTime = str(round(float(spu.attrib['start']), 2))

        spuNodeLenCount += 1
        print('Extracting image at {} {}/{}'.format(str(subtitleStartTime),
              spuNodeLenCount, spuNodeLen))

        # Extract image for subtitle from video
        # Time formats vary, so we have some processing to do
        subtitleStartTimeString = str(subtitleStartTime)
        if subtitleStartTimeString.find('.') == -1:
            subtitleStartTimeString += '.0'
        subtitleStartTimeString += '.jpg'
        outputImg = outDir + '/' + subtitleStartTimeString

        # Ask ffmpeg to extract the image
        cmd = extractImageCmdTemplate.format(subtitleStartTime, outputImg)
        result = subprocess.call(cmd, shell=True)

        # Copy subtitle file
        txtFileSrc = baseDir + '/' + spu.attrib['image'] + '.txt'
        txtFileDest = outDir + '/' + subtitleStartTimeString[:-3] + "txt"
        shutil.copyfile(txtFileSrc, txtFileDest)

# Step 5 - Ask ffmpeg to detect scene changes
if args['detectscenes'] or fullRun or preBuild:

    # Ask ffmpeg to detect scene changes
    sceneRawFile = outDir + '/sceneraw.txt'
    sceneDetectionCmdTemplate = 'ffmpeg -i {} -filter:v "select=\'gt(scene,0.4)\',showinfo" -f null - 2> {}'
    sceneDetectionCmd = sceneDetectionCmdTemplate.format(videoFile,
                                                         sceneRawFile)

    print('[5/7] Detecting scene changes')
    result = subprocess.call(sceneDetectionCmd, shell=True)

    # Use grep to extact the time data
    sceneTimeFile = outDir + '/scenetime.txt'
    sceneTimeCmdTemplate = "grep showinfo {} | grep pts_time:[0-9.]* -o | grep -E '[0-9]+(?:\.[0-9]*)?' -o > {}"  # pylint: disable=all
    sceneTimeCmd = sceneTimeCmdTemplate.format(sceneRawFile, sceneTimeFile)

    print('Extracting timestamps')
    subprocess.call(sceneTimeCmd, shell=True)

# Step 6 - Extract scene changes
if args['extractscenes'] or fullRun or preBuild:
    sceneTimeFile = outDir + '/scenetime.txt'
    print('[6/7] Extracting scene change images')
    extractCmdTemplate = 'ffmpeg -loglevel panic -y -ss {} -i ' + videoFile + ' -vframes 1 -q:v 2 {}'

    with open(sceneTimeFile) as fp:
        for cnt, line in enumerate(fp):

            ts = str(round(float(line), 2))

            # Extract image for subtitle from video
            outputImg = outDir + '/' + str(ts) + '.jpg'
            cmd = extractCmdTemplate.format(ts, outputImg)
            print('Extracting image ' + str(cnt))
            result = subprocess.call(cmd, shell=True)

if preBuild:
    print('Now remove any unwanted images from the _process directory and run with --build to create the PDF')

if args['build'] or fullRun:
    print('[7/7] Building PDF')

    #  Start by sorting the times
    imgList = []
    for file in os.listdir(outDir):
        filename, fileExtension = os.path.splitext(file)
        if fileExtension == '.jpg':
            imgList.append(float(filename))

    imgList.sort()

    lastTs = float(0)

    # Remove any unsubtitled images that are within a second of another
    for i, ts in enumerate(imgList):
        if (ts - lastTs) < 1:
            if os.path.isfile(outDir + '/' + str(ts) + '.txt') is False:
                print('Discarding ' + str(ts))
                del imgList[i]
            elif os.path.isfile(outDir + '/' + str(lastTs) + '.txt') is False:
                print('Discarding ' + str(lastTs))
                del imgList[i - 1]

        lastTs = ts

    # Set up PDF file
    pdf = FPDF()
    pdf.add_font('comic', '', fontFile, True)
    pdf.set_font('comic', '', fontSize)

    imgListLen = len(imgList)
    pageCount = 0

    for i, img in enumerate(imgList):

        print('Image {} of {}'.format(i + 1, imgListLen))

        # Calculate position on page
        if i == 0 or i % 6 == 0:
            pdf.add_page()
            pageCount += 1
            x = 0
            y = 0
        else:
            x = (i % 2) * 100
            y = (((i % 6) & 6) / 2) * 90

        # Top-left padding
        x += 5
        y += 10

        # Add image and subtitle
        pdf.image(name=outDir + '/' + str(img) + '.jpg', x=x, y=y, w=99)

        subtitleFile = outDir + '/' + str(img) + '.txt'
        if os.path.isfile(subtitleFile):

            with open(subtitleFile, 'r') as subtitle_fh:
                subtitleTxt = subtitle_fh.read().strip()

            subtitleTxt = subtitleTxt.strip()
            subtitleTxt = subtitleTxt.replace('\n\n', '\n')

            pdf.set_xy(x, y + fontOffset)
            pdf.multi_cell(w=99, h=fontLineHeight, txt=subtitleTxt, border=0,
                           align='C', fill=False)

    # Final build (this can take a little while depending on how many pages)
    print('Saving PDF')
    pdf.output(pdfFile, 'F')
    print('{} page(s) generated'.format(pageCount))

print('Complete')
